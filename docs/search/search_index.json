{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"jetblack-fixparser \u00b6 A parser for FIX messages.","title":"jetblack-fixparser"},{"location":"#jetblack-fixparser","text":"A parser for FIX messages.","title":"jetblack-fixparser"},{"location":"api/jetblack_fixparser/","text":"jetblack_fixparser \u00b6 module jetblack_fixparser \u00b6 Summary \u00b6 jetblack_fixparser function jetblack_fixparser.loader . load_quickfix_protocol \u00b6 Summary \u00b6 Load a QuickFix style XML protocol file jetblack_fixparser.loader . load_quickfix_protocol ( filename : str , * , is_millisecond_time : bool , is_float_decimal : bool , is_type_enum : Optional[Mapping[ValueType, bool]] ) -> ProtocolMetaData Parameters \u00b6 filename : str (optional) The filename is_millisecond_time : bool If true times have milliseconds. Defaults to True. is_float_decimal : bool If true use Decimal for floating point numbers. Defaults to False. is_type_enum : Optional[Mapping[ValueType, bool]] A map of types to control serialization to enums. Defaults to None. Returns \u00b6 ProtocolMetaData : The protocol meta data. function jetblack_fixparser.loader . load_yaml_protocol \u00b6 Summary \u00b6 Load a YAML style protocol file jetblack_fixparser.loader . load_yaml_protocol ( filename : str , * , is_millisecond_time : bool , is_float_decimal : bool , is_type_enum : Optional[Mapping[ValueType, bool]] ) -> ProtocolMetaData Parameters \u00b6 filename : str (optional) The filename is_millisecond_time : bool If true times have milliseconds. Defaults to True. is_float_decimal : bool If true use Decimal for floating point numbers. Defaults to False. is_type_enum : Optional[Mapping[ValueType, bool]] Map controlling serialization to enums. Defaults to None. Returns \u00b6 ProtocolMetaData : The protocol meta data. class FixMessage \u00b6 Summary \u00b6 Initialise the FIX message jetblack_fixparser.fix_message . FixMessage ( message : Mapping[str, Any] , meta_data : Optional[MessageMetaData] ) -> None Parameters \u00b6 message : Mapping[str, Any] (optional) The fix message in the form of a mapping of message names to values. meta_data : Optional[MessageMetaData] Optional meta data. If this is not supplied it will be discovered from the protocol meta data. Defaults to None. class method FixMessage . decode \u00b6 Summary \u00b6 Decode a FIX bytes buffer. FixMessage . decode ( buffer : bytes , * , strict : bool , validate : bool , sep : bytes , convert_sep_for_checksum : bool ) -> FixMessage Parameters \u00b6 buffer : bytes (optional) The FIX bytes buffer. strict : bool If true apply strict validation. Defaults to True. validate : bool If true validate the message. Defaults to True. sep : bytes The field separator. Defaults to SOH. convert_sep_for_checksum : bool If true convert the separator before calculating the checksum. Defaults to True. Returns \u00b6 FixMessage : A class containing the decoded message. method FixMessage . encode \u00b6 Summary \u00b6 Encode the message into the FIX bytes buffer FixMessage . encode ( sep : bytes , regenerate_integrity : bool , convert_sep_for_checksum : bool ) -> bytes Parameters \u00b6 sep : bytes The field separator. Defaults to SOH. regenerate_integrity : bool If true regenerate the integrity of the message by creating the begin string, body length, and checksum. Defaults to True. convert_sep_for_checksum : bool If true convert the field separator before calculating the checksum. Defaults to False. Returns \u00b6 bytes : The FIX bytes buffer. class FixMessageFactory \u00b6 Summary \u00b6 Initialise the message factory jetblack_fixparser.fix_message . FixMessageFactory ( sender_comp_id : str , target_comp_id : str , * , strict : bool , validate : bool , sep : bytes , convert_sep_for_checksum : bool , header_kwargs : Optional[Mapping[str, Any]] ) -> None Parameters \u00b6 sender_comp_id : str (optional) The sender comp id. target_comp_id : str (optional) The target comp id. strict : bool If true use strict validation. Defaults to True. validate : bool If true validate the message. Defaults to True. sep : bytes The field separator to use. Defaults to SOH. convert_sep_for_checksum : bool If true convert the field separator before calculating the checksum. Defaults to True. header_kwargs : Optional[Mapping[str, Any]] Extra header args. Defaults to None. method FixMessageFactory . create \u00b6 Summary \u00b6 Create a FIX message FixMessageFactory . create ( msg_type : str , msg_seq_num : int , sending_time : datetime , body_kwargs : Optional[Mapping[str, Any]] , header_kwargs : Optional[Mapping[str, Any]] , trailer_kwargs : Optional[Mapping[str, Any]] ) -> FixMessage Parameters \u00b6 msg_type : str (optional) The message type. msg_seq_num : int (optional) The message sequence number. sending_time : datetime (optional) The sending time. body_kwargs : Optional[Mapping[str, Any]] The message body. Defaults to None. header_kwargs : Optional[Mapping[str, Any]] Extra header args. Defaults to None. trailer_kwargs : Optional[Mapping[str, Any]] Extra trailer args. Defaults to None. Returns \u00b6 FixMessage : The FIX message. method FixMessageFactory . decode \u00b6 Summary \u00b6 Decode a FIX message byte buffer. FixMessageFactory . decode ( buffer : bytes ) -> FixMessage Parameters \u00b6 buffer : bytes (optional) The FIX bytes buffer Returns \u00b6 FixMessage : A decoded message. class ValueType ( Enum ) \u00b6 Summary \u00b6 Value types jetblack_fixparser . ValueType ( names : Any , * , module : Any , qualname : Any , type : Any , start : Any ) -> None Parameters \u00b6 names : Any module : Any qualname : Any type : Any start : Any","title":"jetblack_fixparser"},{"location":"api/jetblack_fixparser/#jetblack_fixparser","text":"","title":"jetblack_fixparser"},{"location":"api/jetblack_fixparser/#module-jetblack_fixparser","text":"","title":"module jetblack_fixparser"},{"location":"api/jetblack_fixparser/#summary","text":"jetblack_fixparser","title":"Summary"},{"location":"api/jetblack_fixparser/#function-jetblack_fixparserloaderload_quickfix_protocol","text":"","title":"function jetblack_fixparser.loader.load_quickfix_protocol"},{"location":"api/jetblack_fixparser/#summary_1","text":"Load a QuickFix style XML protocol file jetblack_fixparser.loader . load_quickfix_protocol ( filename : str , * , is_millisecond_time : bool , is_float_decimal : bool , is_type_enum : Optional[Mapping[ValueType, bool]] ) -> ProtocolMetaData","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters","text":"filename : str (optional) The filename is_millisecond_time : bool If true times have milliseconds. Defaults to True. is_float_decimal : bool If true use Decimal for floating point numbers. Defaults to False. is_type_enum : Optional[Mapping[ValueType, bool]] A map of types to control serialization to enums. Defaults to None.","title":"Parameters"},{"location":"api/jetblack_fixparser/#returns","text":"ProtocolMetaData : The protocol meta data.","title":"Returns"},{"location":"api/jetblack_fixparser/#function-jetblack_fixparserloaderload_yaml_protocol","text":"","title":"function jetblack_fixparser.loader.load_yaml_protocol"},{"location":"api/jetblack_fixparser/#summary_2","text":"Load a YAML style protocol file jetblack_fixparser.loader . load_yaml_protocol ( filename : str , * , is_millisecond_time : bool , is_float_decimal : bool , is_type_enum : Optional[Mapping[ValueType, bool]] ) -> ProtocolMetaData","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_1","text":"filename : str (optional) The filename is_millisecond_time : bool If true times have milliseconds. Defaults to True. is_float_decimal : bool If true use Decimal for floating point numbers. Defaults to False. is_type_enum : Optional[Mapping[ValueType, bool]] Map controlling serialization to enums. Defaults to None.","title":"Parameters"},{"location":"api/jetblack_fixparser/#returns_1","text":"ProtocolMetaData : The protocol meta data.","title":"Returns"},{"location":"api/jetblack_fixparser/#class-fixmessage","text":"","title":"class FixMessage"},{"location":"api/jetblack_fixparser/#summary_3","text":"Initialise the FIX message jetblack_fixparser.fix_message . FixMessage ( message : Mapping[str, Any] , meta_data : Optional[MessageMetaData] ) -> None","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_2","text":"message : Mapping[str, Any] (optional) The fix message in the form of a mapping of message names to values. meta_data : Optional[MessageMetaData] Optional meta data. If this is not supplied it will be discovered from the protocol meta data. Defaults to None.","title":"Parameters"},{"location":"api/jetblack_fixparser/#class-method-fixmessagedecode","text":"","title":"class method FixMessage.decode"},{"location":"api/jetblack_fixparser/#summary_4","text":"Decode a FIX bytes buffer. FixMessage . decode ( buffer : bytes , * , strict : bool , validate : bool , sep : bytes , convert_sep_for_checksum : bool ) -> FixMessage","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_3","text":"buffer : bytes (optional) The FIX bytes buffer. strict : bool If true apply strict validation. Defaults to True. validate : bool If true validate the message. Defaults to True. sep : bytes The field separator. Defaults to SOH. convert_sep_for_checksum : bool If true convert the separator before calculating the checksum. Defaults to True.","title":"Parameters"},{"location":"api/jetblack_fixparser/#returns_2","text":"FixMessage : A class containing the decoded message.","title":"Returns"},{"location":"api/jetblack_fixparser/#method-fixmessageencode","text":"","title":"method FixMessage.encode"},{"location":"api/jetblack_fixparser/#summary_5","text":"Encode the message into the FIX bytes buffer FixMessage . encode ( sep : bytes , regenerate_integrity : bool , convert_sep_for_checksum : bool ) -> bytes","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_4","text":"sep : bytes The field separator. Defaults to SOH. regenerate_integrity : bool If true regenerate the integrity of the message by creating the begin string, body length, and checksum. Defaults to True. convert_sep_for_checksum : bool If true convert the field separator before calculating the checksum. Defaults to False.","title":"Parameters"},{"location":"api/jetblack_fixparser/#returns_3","text":"bytes : The FIX bytes buffer.","title":"Returns"},{"location":"api/jetblack_fixparser/#class-fixmessagefactory","text":"","title":"class FixMessageFactory"},{"location":"api/jetblack_fixparser/#summary_6","text":"Initialise the message factory jetblack_fixparser.fix_message . FixMessageFactory ( sender_comp_id : str , target_comp_id : str , * , strict : bool , validate : bool , sep : bytes , convert_sep_for_checksum : bool , header_kwargs : Optional[Mapping[str, Any]] ) -> None","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_5","text":"sender_comp_id : str (optional) The sender comp id. target_comp_id : str (optional) The target comp id. strict : bool If true use strict validation. Defaults to True. validate : bool If true validate the message. Defaults to True. sep : bytes The field separator to use. Defaults to SOH. convert_sep_for_checksum : bool If true convert the field separator before calculating the checksum. Defaults to True. header_kwargs : Optional[Mapping[str, Any]] Extra header args. Defaults to None.","title":"Parameters"},{"location":"api/jetblack_fixparser/#method-fixmessagefactorycreate","text":"","title":"method FixMessageFactory.create"},{"location":"api/jetblack_fixparser/#summary_7","text":"Create a FIX message FixMessageFactory . create ( msg_type : str , msg_seq_num : int , sending_time : datetime , body_kwargs : Optional[Mapping[str, Any]] , header_kwargs : Optional[Mapping[str, Any]] , trailer_kwargs : Optional[Mapping[str, Any]] ) -> FixMessage","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_6","text":"msg_type : str (optional) The message type. msg_seq_num : int (optional) The message sequence number. sending_time : datetime (optional) The sending time. body_kwargs : Optional[Mapping[str, Any]] The message body. Defaults to None. header_kwargs : Optional[Mapping[str, Any]] Extra header args. Defaults to None. trailer_kwargs : Optional[Mapping[str, Any]] Extra trailer args. Defaults to None.","title":"Parameters"},{"location":"api/jetblack_fixparser/#returns_4","text":"FixMessage : The FIX message.","title":"Returns"},{"location":"api/jetblack_fixparser/#method-fixmessagefactorydecode","text":"","title":"method FixMessageFactory.decode"},{"location":"api/jetblack_fixparser/#summary_8","text":"Decode a FIX message byte buffer. FixMessageFactory . decode ( buffer : bytes ) -> FixMessage","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_7","text":"buffer : bytes (optional) The FIX bytes buffer","title":"Parameters"},{"location":"api/jetblack_fixparser/#returns_5","text":"FixMessage : A decoded message.","title":"Returns"},{"location":"api/jetblack_fixparser/#class-valuetypeenum","text":"","title":"class ValueType(Enum)"},{"location":"api/jetblack_fixparser/#summary_9","text":"Value types jetblack_fixparser . ValueType ( names : Any , * , module : Any , qualname : Any , type : Any , start : Any ) -> None","title":"Summary"},{"location":"api/jetblack_fixparser/#parameters_8","text":"names : Any module : Any qualname : Any type : Any start : Any","title":"Parameters"},{"location":"user-guide/factories/","text":"Factories \u00b6 When two parties communicate over FIX they set and sender and target id which never change. We can use a factory to simplify this. To create a message using a factory: from datetime import datetime , timezone from jetblack_fixparser import load_yaml_protocol , FixMessage , FixMessageFactory protocol = load_yaml_protocol ( 'FIX44.yaml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = None ) factory = FixMessageFactory ( protocol , \"SENDER\" , \"TARGET\" ) sending_time = datetime ( 2020 , 1 , 1 , 12 , 30 , 0 , tzinfo = timezone . utc ) fix_messages = factory . create ( 'LOGON' , 42 , sending_time , { 'EncryptMethod' : \"NONE\" , 'HeartBtInt' : 30 } ) buffer = fix_message . encode ( regenerate_integrity = True ) roundtrip = FixMessage . decode ( protocol , buffer ) assert fix_message . message == roundtrip . message","title":"Factories"},{"location":"user-guide/factories/#factories","text":"When two parties communicate over FIX they set and sender and target id which never change. We can use a factory to simplify this. To create a message using a factory: from datetime import datetime , timezone from jetblack_fixparser import load_yaml_protocol , FixMessage , FixMessageFactory protocol = load_yaml_protocol ( 'FIX44.yaml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = None ) factory = FixMessageFactory ( protocol , \"SENDER\" , \"TARGET\" ) sending_time = datetime ( 2020 , 1 , 1 , 12 , 30 , 0 , tzinfo = timezone . utc ) fix_messages = factory . create ( 'LOGON' , 42 , sending_time , { 'EncryptMethod' : \"NONE\" , 'HeartBtInt' : 30 } ) buffer = fix_message . encode ( regenerate_integrity = True ) roundtrip = FixMessage . decode ( protocol , buffer ) assert fix_message . message == roundtrip . message","title":"Factories"},{"location":"user-guide/installation/","text":"Installation \u00b6 The package can be installed with pip . pip install jetblack-fixparser","title":"Installation"},{"location":"user-guide/installation/#installation","text":"The package can be installed with pip . pip install jetblack-fixparser","title":"Installation"},{"location":"user-guide/protocols/","text":"Protocols \u00b6 Messages in FIX rely on a protocol. This protocol describes the fields and the structure of messages. As the protocol developed, new fields, message types, and structural components were added, leading to different versions. See below for an explanation of the message structure. Although the protocol is a \"standard\", it is common that messages may be altered, enriched, or new message types provided. When a FIX connection is provided, both sides agree on the structure of the messages, and create a common protocol. Loaders \u00b6 This package provides two loaders: one for YAML formatted files, and one for the QuickFIx XML format. YAML protocol files \u00b6 The structure of the YAML files is given below. They are loaded in the following manner. from jetblack_fixparser import load_yaml_protocol , ValueType protocol = load_yaml_protocol ( 'FIX42.yaml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = { ValueType . BOOLEAN : False } ) The above example loaded the FIX 4.2 specification. It indicated that times will include milliseconds, floats should be converted to decimals, and that field of type 'BOOLEAN' should not be converted to a text representation. XML protocol files \u00b6 Due to the popularity of the QuickFix engine, the XML format used by this product is widespread, and a loader is provided. You can find the protocol files here . They are loaded in the following manner. from jetblack_fixparser import load_quickfix_protocol , ValueType protocol = load_quickfix_protocol ( 'FIX42.xml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = None ) See the YAML loader for a description of the arguments. Structure \u00b6 This package comes with a set of protocol files in YAML format. Fields \u00b6 Fields have a type , a number , and optionally a list fo values that can give the raw value a readable meaning. Here are a few example fields: fields : Account : number : 1 type : STRING ExecTransType : number : 20 type : CHAR values : 0 : NEW 1 : CANCEL 2 : CORRECT 3 : STATUS Price : number : 44 type : PRICE Header \u00b6 All messages start with a header . The header fields must be presented in order. the order of other parts of the message may have more relaxed ordering constraints. Here is an example header for FIX 4.0 (the most simple): header : BeginString : required : true BodyLength : required : true MsgType : required : true SenderCompID : required : true TargetCompID : required : true OnBehalfOfCompID : DeliverToCompID : SecureDataLen : SecureData : MsgSeqNum : SenderSubID : TargetSubID : OnBehalfOfSubID : DeliverToSubID : PossDupFlag : PossResend : SendingTime : required : true OrigSendingTime : The header consists of a sequence of fields which may be required . Trailer \u00b6 All messages end with a trailer . Here is an example trailer: trailer : SignatureLength : Signature : CheckSum : required : true Messages \u00b6 The messages themselves have a similar structure to header and trailer, but with a message type and category. Here is an example: messages : OrderCancelReject : msgtype : '9' msgcat : app fields : OrderID : required : true ClOrdID : required : true ClientID : ExecBroker : ListID : CxlRejReason : Text :","title":"Protocols"},{"location":"user-guide/protocols/#protocols","text":"Messages in FIX rely on a protocol. This protocol describes the fields and the structure of messages. As the protocol developed, new fields, message types, and structural components were added, leading to different versions. See below for an explanation of the message structure. Although the protocol is a \"standard\", it is common that messages may be altered, enriched, or new message types provided. When a FIX connection is provided, both sides agree on the structure of the messages, and create a common protocol.","title":"Protocols"},{"location":"user-guide/protocols/#loaders","text":"This package provides two loaders: one for YAML formatted files, and one for the QuickFIx XML format.","title":"Loaders"},{"location":"user-guide/protocols/#yaml-protocol-files","text":"The structure of the YAML files is given below. They are loaded in the following manner. from jetblack_fixparser import load_yaml_protocol , ValueType protocol = load_yaml_protocol ( 'FIX42.yaml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = { ValueType . BOOLEAN : False } ) The above example loaded the FIX 4.2 specification. It indicated that times will include milliseconds, floats should be converted to decimals, and that field of type 'BOOLEAN' should not be converted to a text representation.","title":"YAML protocol files"},{"location":"user-guide/protocols/#xml-protocol-files","text":"Due to the popularity of the QuickFix engine, the XML format used by this product is widespread, and a loader is provided. You can find the protocol files here . They are loaded in the following manner. from jetblack_fixparser import load_quickfix_protocol , ValueType protocol = load_quickfix_protocol ( 'FIX42.xml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = None ) See the YAML loader for a description of the arguments.","title":"XML protocol files"},{"location":"user-guide/protocols/#structure","text":"This package comes with a set of protocol files in YAML format.","title":"Structure"},{"location":"user-guide/protocols/#fields","text":"Fields have a type , a number , and optionally a list fo values that can give the raw value a readable meaning. Here are a few example fields: fields : Account : number : 1 type : STRING ExecTransType : number : 20 type : CHAR values : 0 : NEW 1 : CANCEL 2 : CORRECT 3 : STATUS Price : number : 44 type : PRICE","title":"Fields"},{"location":"user-guide/protocols/#header","text":"All messages start with a header . The header fields must be presented in order. the order of other parts of the message may have more relaxed ordering constraints. Here is an example header for FIX 4.0 (the most simple): header : BeginString : required : true BodyLength : required : true MsgType : required : true SenderCompID : required : true TargetCompID : required : true OnBehalfOfCompID : DeliverToCompID : SecureDataLen : SecureData : MsgSeqNum : SenderSubID : TargetSubID : OnBehalfOfSubID : DeliverToSubID : PossDupFlag : PossResend : SendingTime : required : true OrigSendingTime : The header consists of a sequence of fields which may be required .","title":"Header"},{"location":"user-guide/protocols/#trailer","text":"All messages end with a trailer . Here is an example trailer: trailer : SignatureLength : Signature : CheckSum : required : true","title":"Trailer"},{"location":"user-guide/protocols/#messages","text":"The messages themselves have a similar structure to header and trailer, but with a message type and category. Here is an example: messages : OrderCancelReject : msgtype : '9' msgcat : app fields : OrderID : required : true ClOrdID : required : true ClientID : ExecBroker : ListID : CxlRejReason : Text :","title":"Messages"},{"location":"user-guide/usage/","text":"Getting Started \u00b6 Protocol Files \u00b6 While FIX is a standard, the structure of the fields and messages is configurable. This configuration is typically loaded from a file. The source repository contains a number of such files in the /etc folder in YAML format. There is also a QuickFix loader. The YAML format makes use of defaults. All message fields default to type field , so only group and component fields need to be explicitly specified. Also all message fields are consider optional, non-optional fields must be marked as required: true . Usage \u00b6 Decoding \u00b6 To decode a FIX bytes buffer - from jetblack_fixparser import load_yaml_protocol , FixMessage buffer = b '8=FIX.4.4|9=94|35=3|49=A|56=AB|128=B1|34=214|50=U1|52=20100304-09:42:23.130|45=176|371=15|372=X|373=1|58=txt|10=058|' , protocol = load_yaml_protocol ( 'FIX44.yaml' , is_millisecond_time = True , is_float_decimal = True ) fix_message = FixMessage . decode ( protocol , buffer , sep = b '|' , strict = True , validate = True , convert_sep_for_checksum = True ) print ( fix_message . message ) Note that strict validation is enabled. This ensures all required fields are specified. Also the separator is changed from NULL to | to so they can be displayed. However the checksum was calculated with the original field separator so the convert_sep_for_checksum is set to true . Encoding \u00b6 To encode a dictionary describing a FIX message - from datetime import datetime , timezone from jetblack_fixparser import load_yaml_protocol , FixMessage protocol = load_yaml_protocol ( 'FIX44.yaml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = None ) sending_time = datetime ( 2020 , 1 , 1 , 12 , 30 , 0 , tzinfo = timezone . utc ) fix_message = FixMessage ( protocol , { 'MsgType' : 'LOGON' , 'MsgSeqNum' : 42 , 'SenderCompID' : \"SENDER\" , 'TargetCompID' : \"TARGET\" , 'SendingTime' : sending_time , 'EncryptMethod' : \"NONE\" , 'HeartBtInt' : 30 } ) buffer = fix_message . encode ( regenerate_integrity = True ) print ( buffer ) Note that the BeginString , BodyLength and Checksum fields were automatically generated.","title":"Getting Started"},{"location":"user-guide/usage/#getting-started","text":"","title":"Getting Started"},{"location":"user-guide/usage/#protocol-files","text":"While FIX is a standard, the structure of the fields and messages is configurable. This configuration is typically loaded from a file. The source repository contains a number of such files in the /etc folder in YAML format. There is also a QuickFix loader. The YAML format makes use of defaults. All message fields default to type field , so only group and component fields need to be explicitly specified. Also all message fields are consider optional, non-optional fields must be marked as required: true .","title":"Protocol Files"},{"location":"user-guide/usage/#usage","text":"","title":"Usage"},{"location":"user-guide/usage/#decoding","text":"To decode a FIX bytes buffer - from jetblack_fixparser import load_yaml_protocol , FixMessage buffer = b '8=FIX.4.4|9=94|35=3|49=A|56=AB|128=B1|34=214|50=U1|52=20100304-09:42:23.130|45=176|371=15|372=X|373=1|58=txt|10=058|' , protocol = load_yaml_protocol ( 'FIX44.yaml' , is_millisecond_time = True , is_float_decimal = True ) fix_message = FixMessage . decode ( protocol , buffer , sep = b '|' , strict = True , validate = True , convert_sep_for_checksum = True ) print ( fix_message . message ) Note that strict validation is enabled. This ensures all required fields are specified. Also the separator is changed from NULL to | to so they can be displayed. However the checksum was calculated with the original field separator so the convert_sep_for_checksum is set to true .","title":"Decoding"},{"location":"user-guide/usage/#encoding","text":"To encode a dictionary describing a FIX message - from datetime import datetime , timezone from jetblack_fixparser import load_yaml_protocol , FixMessage protocol = load_yaml_protocol ( 'FIX44.yaml' , is_millisecond_time = True , is_float_decimal = True , is_type_enum = None ) sending_time = datetime ( 2020 , 1 , 1 , 12 , 30 , 0 , tzinfo = timezone . utc ) fix_message = FixMessage ( protocol , { 'MsgType' : 'LOGON' , 'MsgSeqNum' : 42 , 'SenderCompID' : \"SENDER\" , 'TargetCompID' : \"TARGET\" , 'SendingTime' : sending_time , 'EncryptMethod' : \"NONE\" , 'HeartBtInt' : 30 } ) buffer = fix_message . encode ( regenerate_integrity = True ) print ( buffer ) Note that the BeginString , BodyLength and Checksum fields were automatically generated.","title":"Encoding"}]}